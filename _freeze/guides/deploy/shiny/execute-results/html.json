{
  "hash": "75ae9a6347edb9a45f8032a43a1a57a5",
  "result": {
    "markdown": "---\ntitle: \"Deploying a Shiny app with a TensorFlow model\"\ntype: docs\nmenu:\n  main:\n    name: \"Shiny\"\n    identifier: \"deploy-shiny\"\n    parent: \"deploy-top\"\n    weight: 10\neditor_options: \n  chunk_output_type: console\naliases:\n  - ../../deploy/shiny/index.html\n---\n\n\nIn this tutorial you will learn how to deploy a TensorFlow model inside a Shiny app.\nWe will build a model that can classify handwritten digits in images, then we will\nbuild a Shiny app that let's you upload an image and get predictions from this model.\n\n## Building the model\n\nThe first thing we are going to do is to build our model.\nWe will use the Keras API to build this model.\n\nWe will use the MNIST dataset to build our model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras)\nlibrary(tensorflow)\nmnist <- dataset_mnist()\n\nmnist$train$x <- (mnist$train$x/255) %>% \n  array_reshape(., dim = c(dim(.), 1))\n\nmnist$test$x <- (mnist$test$x/255) %>% \n  array_reshape(., dim = c(dim(.), 1))\n```\n:::\n\n\nNow, we are going to define our Keras model, it will be a simple convolutional neural \nnetwork.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- keras_model_sequential() %>% \n  layer_conv_2d(filters = 16, kernel_size = c(3,3), activation = \"relu\") %>% \n  layer_max_pooling_2d(pool_size = c(2,2)) %>% \n  layer_conv_2d(filters = 16, kernel_size = c(3,3), activation = \"relu\") %>% \n  layer_max_pooling_2d(pool_size = c(2,2)) %>% \n  layer_flatten() %>% \n  layer_dense(units = 128, activation = \"relu\") %>% \n  layer_dense(units = 10, activation = \"softmax\")\n\nmodel %>% \n  compile(\n    loss = \"sparse_categorical_crossentropy\",\n    optimizer = \"adam\",\n    metrics = \"accuracy\"\n  )\n```\n:::\n\n\nNext, we fit the model using the MNIST dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel %>% \n  fit(\n    x = mnist$train$x, y = mnist$train$y,\n    batch_size = 32,\n    epochs = 5,\n    validation_sample = 0.2,\n    verbose = 2\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 1/5\n1875/1875 - 7s - loss: 0.1730 - accuracy: 0.9477 - 7s/epoch - 4ms/step\nEpoch 2/5\n1875/1875 - 5s - loss: 0.0558 - accuracy: 0.9829 - 5s/epoch - 3ms/step\nEpoch 3/5\n1875/1875 - 4s - loss: 0.0387 - accuracy: 0.9879 - 4s/epoch - 2ms/step\nEpoch 4/5\n1875/1875 - 4s - loss: 0.0300 - accuracy: 0.9905 - 4s/epoch - 2ms/step\nEpoch 5/5\n1875/1875 - 5s - loss: 0.0226 - accuracy: 0.9926 - 5s/epoch - 3ms/step\n```\n:::\n:::\n\n\nWhen we are happy with our model accuracy in the validation dataset we can `evaluate` \nthe results on the test dataset with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel %>% evaluate(x = mnist$test$x, y = mnist$test$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n313/313 - 0s - loss: 0.0315 - accuracy: 0.9890 - 449ms/epoch - 1ms/step\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n      loss   accuracy \n0.03146039 0.98900002 \n```\n:::\n:::\n\n\nOK, we have 99% accuracy on the test dataset and we want to deploy that model.\nFirst, let's save the model in the `SavedModel` format using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave_model_tf(model, \"cnn-mnist\")\n```\n:::\n\n\nWith the model built and saved we can now start building our plumber API file.\n\n## Shiny app\n\nA simple shiny app can be define in an `app.R` file with a few conventions. Here's\nhow we can structure our Shiny app.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(keras)\n\n# Load the model\nmodel <- load_model_tf(\"cnn-mnist/\")\n\n# Define the UI\nui <- fluidPage(\n  # App title ----\n  titlePanel(\"Hello TensorFlow!\"),\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n      # Input: File upload\n      fileInput(\"image_path\", label = \"Input a JPEG image\")\n    ),\n    # Main panel for displaying outputs ----\n    mainPanel(\n      # Output: Histogram ----\n      textOutput(outputId = \"prediction\"),\n      plotOutput(outputId = \"image\")\n    )\n  )\n)\n\n# Define server logic required to draw a histogram ----\nserver <- function(input, output) {\n  \n  image <- reactive({\n    req(input$image_path)\n    jpeg::readJPEG(input$image_path$datapath)\n  })\n  \n  output$prediction <- renderText({\n    \n    img <- image() %>% \n      array_reshape(., dim = c(1, dim(.), 1))\n    \n    paste0(\"The predicted class number is \", predict_classes(model, img))\n  })\n  \n  output$image <- renderPlot({\n    plot(as.raster(image()))\n  })\n  \n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nThis app can be used locally or deployed using any Shiny deployment option.\nIf you are deploying to RStudio Connect or Shinnyapps.io, don't forget to set the `RETICULATE_PYTHON` environment variable so `rsconnect` can detect what python\npackages are required to reproduce your local environment. See the [F.A.Q.](https://support.rstudio.com/hc/en-us/articles/360016990813-FAQ-for-Using-Python-with-RStudio-Connect) for more information.\n\n![](images/shiny.png)\n\nYou can see a live version of this app [here](https://beta.rstudioconnect.com/content/7325/). Note that to keep the code simple, it will only accept JPEG images with 28x28 pixels. You can download [this file](images/mnist.jpeg) if you want to try the app.\n\n## More advanced models\n\nWhen building more advanced models you may not be able to save the entire model using the `save_model_tf` function. In this case you can use the `save_model_weights_tf` function. \n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave_model_weights_tf(model, \" cnn-model-weights\")\n```\n:::\n\n\nThen, in the `api.R` file whenn loading the model you will need to rebuild the model using the exact same code that you used when training and saving and then use `load_model_weights_tf` to load\nthe model weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- keras_model_sequential() %>% \n  layer_conv_2d(filters = 16, kernel_size = c(3,3), activation = \"relu\") %>% \n  layer_max_pooling_2d(pool_size = c(2,2)) %>% \n  layer_conv_2d(filters = 16, kernel_size = c(3,3), activation = \"relu\") %>% \n  layer_max_pooling_2d(pool_size = c(2,2)) %>% \n  layer_flatten() %>% \n  layer_dense(units = 128, activation = \"relu\") %>% \n  layer_dense(units = 10, activation = \"softmax\")\n\nload_model_weights_tf(model, \"cnn-model-weights\")\n```\n:::\n\n\n## Hosting the shiny app\n\nThis Shiny app can be hosted in any server using the Shiny Server. If you are managing the complete infrastructure, make sure that you have Python and all required Python packages\ninstalled in the server. \n\nIf you are using [Shinyapps.io](https://shinyapps.io) or [RStudio Connect](https://rstudio.com/products/connect/) the dependencies will be infered when deploying the app. In this case, don't forget to set the `RETICULATE_PYTHON` environment variable.\n\nYou can find more examples of using reticulate in RStudio products [here](https://github.com/sol-eng/python-examples) and learn more about Python in \nRStudio Connect best practices [here](https://support.rstudio.com/hc/en-us/articles/360022909454-Best-Practices-for-Using-Python-with-RStudio-Connect).\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}